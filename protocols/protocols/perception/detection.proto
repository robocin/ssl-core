syntax = "proto3";

package protocols.perception;

import "google/protobuf/timestamp.proto";
import "protocols/common/geometry.proto";
import "protocols/common/robot_id.proto";

// Detection is the message sent by the vision service to the rest of the system.
message Detection {
  // Properties is the message describing the properties of the detection.
  message Properties {
    // The incremental unique id of the detection.
    uint64 serial_id = 1;
    // The unix timestamp of the detection creation.
    google.protobuf.Timestamp created_at = 2;
    // The expected rate of detections generated.
    float fps = 3;
  }

  // The generation properties of the detection.
  Properties properties = 1;

  // The list of detected balls, in order of confidence.
  repeated Ball balls = 2;
  // The list of detected robots (both teams).
  repeated Robot robots = 3;
  // The field information (sent periodically).
  optional Field field = 4;
}

// Ball is the message describing a game ball.
message Ball {
  // TODO(#33): add source.
  reserved 1;
  reserved "source";

  // The confidence of the ball detection.
  float confidence = 2;

  // The 3D position of the ball in the field (in millimeters).
  common.Point3Df position = 3;
  // The 3D velocity of the ball in the field (in millimeters per second).
  common.Point3Df velocity = 4;
  // TODO(#32): add ball acceleration.
  reserved 5;
  reserved "acceleration";
}

// Robot is the message describing a game robot.
message Robot {
  // TODO(#33): add source.
  reserved 1;
  reserved "source";

  // The confidence of the robot detection.
  float confidence = 2;

  // The id of the robot.
  common.RobotId robot_id = 3;

  // The 2D position of the robot in the field (in millimeters).
  common.Point2Df position = 4;
  // The angle pointing in the direction the robot is facing, i.e. the robot's orientation (in radians).
  float angle = 5;

  // The 2D velocity of the robot in the field (in millimeters per second).
  common.Point2Df velocity = 6;
  // The angular velocity of the robot (in radians per second).
  float angular_velocity = 7;

  // TODO(#32): add robot acceleration.
  reserved 8;
  reserved "acceleration";

  // PhysicalAttributes is the message describing the physical attributes of the robot.
  message PhysicalAttributes {
    // The radius of the robot (in millimeters).
    float radius = 1;
    // The height of the robot (in millimeters).
    float height = 2;
    // The width of the dribbler (in millimeters).
    float dribbler_width = 3;
  }

  // The physical attributes of the robot.
  PhysicalAttributes physical_attributes = 9;

  // Feedback is the message describing the feedback from the robot.
  message Feedback {
    // Indicates if the dribbler has contact with the ball.
    optional bool dribbler_ball_contact = 1;
    // The charge percentage of the kick mechanism (from 0 to 1).
    optional float kick_charge_percentage = 2;
    // The battery percentage (from 0 to 1).
    optional float battery_percentage = 3;

    // Wheel is the message describing the state of an individual wheel.
    message Wheel {
      // The identifier for the wheel.
      int32 wheel_id = 1;
      // The speed of the motor for the wheel.
      float motor_speed = 2;
    }

    // The list of wheels and their respective states.
    repeated Wheel wheels = 4;
  }

  // The feedback from the robot.
  Feedback feedback = 10;
}

// Field is the message describing the game field.
message Field {
  // The incremental unique id of the field.
  uint64 serial_id = 1;

  // The length of the field (in millimeters).
  float length = 2;
  // The width of the field (in millimeters).
  float width = 3;
  // The depth of the goal (in millimeters).
  float goal_depth = 4;
  // The width of the goal (in millimeters).
  float goal_width = 5;
  // The depth of the penalty area (in millimeters).
  float penalty_area_depth = 6;
  // The width of the penalty area (in millimeters).
  float penalty_area_width = 7;
  // The width of the boundary (in millimeters).
  float boundary_width = 8;
  // The distance from the goal center to the penalty mark (in millimeters).
  float goal_center_to_penalty_mark = 9;
}
